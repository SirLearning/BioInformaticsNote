[[BioInformaticsNote/4Database/README|README]]

# 产生背景

产生原因：新应用的需求和传统数据库的局限性

**关系数据库系统的不足**
- **结构简单**：不能很好地模拟复杂对象。
- **数据类型简单**：没有定义抽象数据类型的能力。
- **结构与行为分离**：数据库中的信息仅能由识别它们的应用程序解释执行。
- **查询实现复杂**：连接优化降低了存取效率。

面向对象数据库与关系数据库的对比：
- **RDBMS（关系数据库管理系统）**
	- **数据模型**：关系模型。
	- **数据操作**：SQL语言。
	- **数据存储**：表格形式。
- **OODBMS（面向对象数据库管理系统）**
	- **数据模型**：面向对象模型。
	- **数据操作**：对象查询语言。
	- **数据存储**：对象形式。

# 面向对象程序设计语言

**特点**
- **模块化设计**：支持模块化设计。
	- **以对象为中心**：以数据上的操作作为界面进行设计。
- **软件复用**：
	- 对象封装：对象封装使程序员可以通过界面理解和操作对象。
	- 对象继承：对象继承允许复用具有相同特征的其他对象代码。
- **软件维护**：面向对象的软件开发在开发和维护阶段结构一致，易于维护。

**影响领域**
- **程序设计语言**：Java、C++、Python等。
- **人工智能**：智能代理、专家系统。
- **软件工程**：UML建模、敏捷开发。
- **信息系统设计**：CAD/CAM、GIS、ERP。
- **计算机硬件设计**：面向对象的硬件设计。

面向对象数据库系统：
- 包括：ObjectStore、O2、Orion、Versant、Gemstone、Itasca
- 应用：
	- **计算机辅助设计与制造（CAD/CAM）**
	- **计算机集成制造（CIM）**
	- **计算机辅助软件工程（CASE）**
	- **地理信息系统（GIS）**
	- **企业资源规划（ERP）**
	- **能源管理系统（EMS）**

# 数据模型

面向对象 (OO) 数据模型：用面向对象的观点描述现实世界对象的逻辑组织、对象之间的限制、联系的模型称为OO数据模型。

**对象**：具有状态（属性）和行为（方法）的实体。包括简单对象、复杂对象
- 特征：
	- 属性集合      描述对象的状态、组成和特征
	- 方法集合      描述对象的行为特征
	- 消息集合      是对象向外提供的界面，由对象接收和响应
- 对象标识：每个对象都有一个内部标识符OID，OID在整个系统中 是唯一的，一旦生成就不能改变。
	- OID的标识：
		- 值标识      由对象的属性组成对象标识
		- 指针标识    指向物理存储位置的指针作为对象标识
		- 代用品法（surrogate），与对象的内部属性无关。
	- <类标识，实例标识>
- **封装**：每个对象都是其状态和行为的封装体。

**类**：具有相同特征对象的集合。对象为类中的实例
- 类本身看作对象，称为类对象。
- 面向对象数据库模式是类的集合，形成类层次结构
- 类层次
	- 一组相关类形成类层次结构
	- 子类、超类
	- 子类和超类的关系体现了“is A”的语义

**继承**：子类和超类间具有继承关系
- 子类继承超类的属性和方法
- 单继承和多继承
- 解决同名冲突的方法：**单继承和多继承**
	- 子类与超类间的同名冲突按子类优先处理；
	- 多个超类间的同名冲突，按说明超类的先后取第一个超类中的定义 或 规定继承的超类；
	- 提供显式方法: 从多个冲突的实例变量或方法中继承一个；继承多个，在类定义中重新命名。

多态性：同一操作有不同的实现，取决于具体对象。如“＋”法

滞后联编：可以对对象操作的编译推迟到运行时实现，称滞后联编

对象的嵌套：复合类层次结构

# 面向对象数据库的查询

面向对象数据库：因为缺少对象代数理论，目前对这方面的研究还不够，只提供两种查询功能
- 一般查询
	- 对单一类中对象的查询
	- 以类为根的类层次上的查询
- 索引技术：两类
	- 类层次索引：在单一类上建立的索引称为单一索引
		- 建立在类C的属性A上的一个类层次索引，是以该类为根的类层次中所有类在属性A上的单一索引，属性A称为索引属性，类C称为索引类。
	- 嵌套属性索引：在复合类层次的某个类的属性上建立索引。
		- 这种索引是以索引类为根的类复合层次中某个类的属性，该属性称为索引类的嵌套属性。

OODB语言标准：大多采用了扩充SQL语言的方法，称为OSQL

1. **查询语言**
	- **对象查询语言（OQL）**：类似于SQL，但支持对象和类的查询。
2. **查询优化**
	- **索引**：提高查询效率。
	- **缓存**：减少对数据库的访问次数。
	- **并行处理**：利用多核处理器提高查询速度。

# OODB的并发控制

OODBS中的更新处理：
- 当一个事务访问某个类的实例时其它事务不能对这个类的任何超类进行修改。 
- 一个事务在查询计算时其它事务也不能修改该类的所有子类。 查询一个类时要对该类和所有子类进行评估。

锁：在OODBMS中需要提供更复杂的锁机制，需要锁更多的语义信息。
- 锁的粒度有：
	- RDBS中的锁粒度：
		- 逻辑单元（属性、元组、表、数据库）
		- 物理单元（数据页、索引页、数据块）
	- OODBMS中锁的粒度：数据库、类、对象、属性、物理页等
- 多粒度封锁
	- 概念：
		- 允许类层次中的每个结点单独加锁
		- 对一个结点加锁，其下层结点也被加以同样类型的隐式锁
	- l在多粒度封锁中一个数据对象可以两种方式封锁：
		- 显式封锁：通过上锁命令（LOCK）直接加到数据对象上的封锁
		- 隐式封锁：
			- 该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象隐式加了锁。
			- 隐式锁和显式锁的作用是一样的
- 对某个数据对象加锁时系统检查的内容：
	- 该数据对象：有无显式封锁与之冲突
	- 所有上级结点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点封锁造成的）
	- 所有下级结点：看上面的显式封锁是否与本事务的隐式封锁（ 加到下级结点的封锁）冲突
- 意向锁（intention lock）
	- 引进意向锁目的：
		- 提高对数据对象加锁时系统的检查效率
		- 引入意向锁，在某对象实例上加S或X锁前，先在其祖先结点上加意向锁 ，事务T对类C请求 加X锁时，只要检查该类上的意向锁即可
	- 概念：
		- 对任一结点加基本锁，必须先对它的上层结点加意向锁
		- 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁
	- 常用意向锁：
		- 意向共享锁(Intent Share Lock，简称IS锁)：对一个数据对象加IS锁，表示事务可能对类中的实例显式请求S锁。
		- 意向排它锁(Intent Exclusive Lock，简称IX锁)：在类上加IX锁表示事务可能对类中实例显式请求X或S锁。
		- 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)：SIX=S+IX，在类上加SIX锁表示对类中所有实例都隐式地加了S锁。表示该事务要读类中实例，还可能对一些实例请求X锁。因此，仅允许其它事务读但不允许更新类中的实例。
			- SIX锁的引入是必要的。合适于需要查询类中的大量实例而仅更新少数实例的情况。否则，若仅加IX锁，对只需读操作的那些实例为防止其它事务写都要加S锁，增加了锁的开销。
- 共享锁(S)： 加S锁表示该事务读类中实例。
- 排它锁(X)：该事务要修改类中的实例，请求X锁。
- 在OODBS中多粒度加锁的规则： 
	- 若事务对类层次中的某个粒度上加S锁，则在其所有祖先上都要加IS锁。
	- 若事务对类层次中的某个粒度上加X锁，在该粒度的所有祖先粒度上要加IX锁或SIX锁。
	- 若事务已获得对一个类的某个锁，则该类的所有子孙也隐含获得同样的锁。
	- 加锁从类层次的根开始依此往下进行直到事务申请锁的那个粒度，而解锁时的顺序则是由下而上的。
-   ORACLE的锁：
	- 行共享锁 (RS)：可以上SRX、RS、RX、S锁 
		- `LOCK TABLE <表名>IN  ROW SHARE MODE`
	- 行排它锁 (RX)：可以上RS、RX锁 
		- `LOCK TABLE <表名>IN  ROW EXCLUSIVE MODE`
	- 共享表锁 (S)：可以上RS、S锁  
		- `LOCK TABLE <表名>IN  SHARE MODE`
	- 共享行排它表锁 (SRX)：可以上RS锁 
		- `LOCK TABLE <表名>IN  SHARE ROW EXCLUSIVE MODE`
	- 排它表锁 (X)
		- `LOCK TABLE <表名> IN    EXCLUSIVE MODE`

# 面向对象数据库管理系统

面向对象数据库系统：是面向对象技术与数据库技术相相结合的产物，主要的研制方法有：
- 独立开发一个全新的 OODBMS，支持面向对象的模型并具有定义和操作对象的功能；
- 从传统的关系数据库加以扩展，增加面向对象特性，建立对象--关系数据库管理系统（ORDBMS)。
- 在面向对象程序设计语言的基础上扩展数据库功能，形成OODBMS。

ORION：是全新的OODBMS
- 系统结构：
	- 消息处理子系统：负责处理发给对象的所有消息；
	- 对象子系统：对象的存取操作、版本管理、查询优化、多媒体信息管理；
	- 事务管理子系统：提供并发控制和恢复机制；
	- 存储子系统：该子系统包括页缓冲区管理和磁盘管理二个子系统，负责存储在磁盘上对象的存取。
- 数据模型：
	- ORION支持面向对象的核心概念：对象、类、消息、方法。
	- ORION采用多重继承：一个类可以有多个超类。
	- 解决同名冲突的方法：
		- 类与超类间的同名冲突按子类优先处理；
		- 多个超类间的同名冲突，按说明超类的先后取第一个超类中的定义；
		- 提供显式方法: 从多个冲突的实例变量或方法中继承一个；继承多个，在类定义中重新命名。

ORION中定义Object作为类层次结构的根
- ORION中的对象有：复合对象、依赖对象、独立对象
	- 独立对象：独立于其它对象存在的对象，可以被其它对象所引用。比如学生，书本等。
	- 依赖对象：一个对象的存在依赖于另一个对象，如果另一个对象不存在了，这个对象也将自行消失。
		- 依赖对象只能由一个对象所拥有。例如，装在车上的发动机只能为一辆汽车所有，是依赖于汽车的。
	- 复合对象：一个对象全部或部分由多个依赖对象组成。一个复合对象被删除，所有依赖对象也必须被删除。
- 一个对象与组成它的对象间有两种关系：
	- 一种是对独立对象的“引用”关系
	- 另一种是对依赖对象的“拥有”

模式进化：也就是模式修改。
- 关系象数据库模式的进化(schema evolution)
	- 表现为可以动态增加和删除一个关系模式、增加和删除一个关系模式中的列以及改变列的数据类型等。系统的处理仅仅是简单地在数据字典中记录这些改变，一个关系模式的改变不会影响其他关系模式及其元组的改变。
	- 但在面向对象数据库中，由于类层次的复杂语义和继承性，使模式修改的处理相当复杂。比如，增加一个新类，新类不但要继承被指定为超类的的实例变量和方法，而且还要提供被指定为其子类所需要继承的实例变量和方法。
	- 面向对象数据库系统应支持模式修改，但不同的系统有不同的处理策略。ORION体统了动态修改数据模式的功能。
- 面向对象数据库模式的进化(schema evolution)
	- 修改数据库模式：修改类结构、类格的继承结构（类格指类的层次结构）
		- 类定义的修改：对实例变量和方法的修改；增删属性和方法。
		- 对类格的修改：增、删一个类或超类，改变类名或改变超类名的顺序。
- ORION为动态修改数据库模式的功能提供了一组约束规则：
	- 模式进化操作分类
		- 结点的修改(增删类、改类名)
		- 类格结点内容的修改(增删变量和方法)
		- 边的修改(超类子类关系的修改)
	- 模式进化的不变性(一致性)：模式修改后保持成立的特性（模式一致性:  模式内部的一致性约束）
		- 同一类中的类名、变量名和方法名的唯一性
		- 被引用的类、操作和实现必须存在
		- 子类/超类不能有环、多继承不能有冲突
	- 模式进化规则：
		- 冲突解决规则：发生命名冲突时的继承规则
		- 性质传播(修改传播)规则：修改超类结果传播给子类
		- DAG（有向无环图）操纵规则：对类格修改的规则：增加一个子类的超类，该超类排在所有超类的最后

版本管理
- 版本：类对象版本、实例对象版本
- ORION提供二类版本：
	1. 临时版本：可修改和删除，可由它导出新的临时版本，而原来的临时版本升为工作版本。
	2. 工作版本：它是稳定的，只能查看不能修改，可导出临时版本。
- 版本对象描述：对象标识符、版本号、版本状态（临时、工作 )
- 对版本操作命令：
	- Create   ( 创建版本对象，生成对象结构)；
	- Derive    ( 派生新的临时版本)；
	- Replace  ( 替换临时版本的内容)；
	- Delete     ( 删除版本)；
	- Promote ( 改临时版本工作版本).

对象的储存管理：
- 二元存储：<OID，实例变量>
	- 基于对象的存储：
		- 对象存储格式：`对象标识     对象长度     属性数     属性向量     值位移向量      值`
	- 类层次结构对象的存储
		- 属性值存储在尽可能低的层次
		- 属性值存储在较高的层次，还可以将属性值按不同层次分别存储
- ORION中采用了基于类层次结构对象的存储策略，尽可能将类中的实例存储在类层次的最低层。

OODB存在的问题：
- 已有OODBMS在程序设计接口、实现方法、对查询的支持等多个方面存在许多差异；
- 模式进化难于实现；
- 与应用程序密切相关，许多系统仅支持一种语言
- 健壮性、容错性；
- 缺乏开发工具。

# 对象-关系数据库系统

在关系系统基础上应具有以下特征：
- 扩充数据类型
	- LOB（大对象）
	- BOOLEAN
	- 集合类型ARRAY
	- 用户定义的DISTINCT类型
	- 面向对象的数据类型
		- 行类型ROW TYPE
		- 抽象数据类型（Abstract Data Type）
- 支持复杂对象管理
	- 对象—关系数据库系统中关系的属性域是非原子的，可以用复合数据类型表示，也可以是一个关系，称为嵌套关系。
	- 复合数据类型：
		- 组合类型：由不同类型数据值组成，简单类型或复合类型
			- `CREATE TYPE <类型名> (<属性名 数据类型> [, <属性名 数据类型>, ……]);`
		- 集合类型：相同类型值的组合：用关键词 setof(T)说明，T是任意数据类型。 setof(T) 是类型为T的值的集合数据类型
		- 引用类型：指向任意类型实例的指针：用关键词 ref(T)，T可以是任意数据类型
- 支持继承（子类 / 超类，单继承/多继承）
	- 继承可以在类型一级说明
		- `CREATE  TYPE    …     UNDER  <超类名>`
	- 也可以用于表一级：直接在定义表中给出继承关系
		- `CREATE  TABLE  …    UNDER  <超类名>`
	- 多重继承：UNDER 后说明多个类型。
		- `CREATE  TYPE   teacher_stdent_t (credit  integer）UNDER teacher_t, student_t；`
		- 多重继承会出现属性冲突，解决方法有：
			- 在超类中重新定义冲突属性名
			- 在子类中重新定义冲突属性名
- 提供通用规则系统（自定义函数、规则的继承等）
	- 函数：ORDBMS中不但提供了复合数据类型，还提供了用户自定义函数的功能。用户可以用SQL语言或通用的编程语言定义函数。
- 数据查询：ORDBMS中的数据操作需对SQL进行扩充，查询与数据类型有关，可分为三种
	- 与组合类型有关的查询
	- 与集合类型有关的查询
	- 与引用类型有关的查询
- Oracle 的对象-关系特征：对象-关系数据库系统具有面向对象和关系数据库的双重优点，现在许多关系库的新版本中增加了面向对象的特征，如Oracle8
	- 扩展数据类型
		- 可变长数组类型：VARRAY
		- Oracle可以存储大对象，如视频、音频、文本文档
			- BLOB：二进制大对象
			- CLOB：字符大对象  
			- BFILE：存储在数据库外部的 二进制文件，其目录名存储在数据库内
	- 使用嵌套表表示复杂对象
